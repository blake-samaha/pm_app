/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * PM App API
 * Automated Project Management Tool API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    ActionItemCreate,
    ActionItemRead,
    CommentCreate,
    CommentRead,
    HTTPValidationError,
    ReadActionsActionsGet200,
    ReadActionsActionsGetParams,
} from ".././models";

import { customInstance } from "../../orvalMutator";
import type { ErrorType, BodyType } from "../../orvalMutator";

/**
 * Get actions for a project.

If limit/offset are provided, returns paginated response with total count.
Otherwise returns all actions (legacy behavior) with X-Total-Count header.

- **limit**: Maximum number of results (1-100)
- **offset**: Number of results to skip
- **search**: Optional search term for title or Jira ID
- **status**: Optional status filter (can be repeated)
 * @summary Read Actions
 */
export const readActionsActionsGet = (
    params: ReadActionsActionsGetParams,
    signal?: AbortSignal
) => {
    return customInstance<ReadActionsActionsGet200>({
        url: `/actions/`,
        method: "GET",
        params,
        signal,
    });
};

export const getReadActionsActionsGetQueryKey = (params?: ReadActionsActionsGetParams) => {
    return [`/actions/`, ...(params ? [params] : [])] as const;
};

export const getReadActionsActionsGetQueryOptions = <
    TData = Awaited<ReturnType<typeof readActionsActionsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadActionsActionsGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readActionsActionsGet>>, TError, TData>
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getReadActionsActionsGetQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readActionsActionsGet>>> = ({
        signal,
    }) => readActionsActionsGet(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof readActionsActionsGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadActionsActionsGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof readActionsActionsGet>>
>;
export type ReadActionsActionsGetQueryError = ErrorType<HTTPValidationError>;

export function useReadActionsActionsGet<
    TData = Awaited<ReturnType<typeof readActionsActionsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadActionsActionsGetParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readActionsActionsGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof readActionsActionsGet>>,
                    TError,
                    Awaited<ReturnType<typeof readActionsActionsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReadActionsActionsGet<
    TData = Awaited<ReturnType<typeof readActionsActionsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadActionsActionsGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readActionsActionsGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof readActionsActionsGet>>,
                    TError,
                    Awaited<ReturnType<typeof readActionsActionsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReadActionsActionsGet<
    TData = Awaited<ReturnType<typeof readActionsActionsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadActionsActionsGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readActionsActionsGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Read Actions
 */

export function useReadActionsActionsGet<
    TData = Awaited<ReturnType<typeof readActionsActionsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadActionsActionsGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readActionsActionsGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getReadActionsActionsGetQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Create a new action item.
 * @summary Create Action
 */
export const createActionActionsPost = (
    actionItemCreate: BodyType<ActionItemCreate>,
    signal?: AbortSignal
) => {
    return customInstance<ActionItemRead>({
        url: `/actions/`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: actionItemCreate,
        signal,
    });
};

export const getCreateActionActionsPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createActionActionsPost>>,
        TError,
        { data: BodyType<ActionItemCreate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createActionActionsPost>>,
    TError,
    { data: BodyType<ActionItemCreate> },
    TContext
> => {
    const mutationKey = ["createActionActionsPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createActionActionsPost>>,
        { data: BodyType<ActionItemCreate> }
    > = (props) => {
        const { data } = props ?? {};

        return createActionActionsPost(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateActionActionsPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof createActionActionsPost>>
>;
export type CreateActionActionsPostMutationBody = BodyType<ActionItemCreate>;
export type CreateActionActionsPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Action
 */
export const useCreateActionActionsPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createActionActionsPost>>,
            TError,
            { data: BodyType<ActionItemCreate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof createActionActionsPost>>,
    TError,
    { data: BodyType<ActionItemCreate> },
    TContext
> => {
    const mutationOptions = getCreateActionActionsPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get a specific action item by ID.
 * @summary Get Action
 */
export const getActionActionsActionIdGet = (actionId: string, signal?: AbortSignal) => {
    return customInstance<ActionItemRead>({ url: `/actions/${actionId}`, method: "GET", signal });
};

export const getGetActionActionsActionIdGetQueryKey = (actionId?: string) => {
    return [`/actions/${actionId}`] as const;
};

export const getGetActionActionsActionIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getActionActionsActionIdGet>>, TError, TData>
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetActionActionsActionIdGetQueryKey(actionId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionActionsActionIdGet>>> = ({
        signal,
    }) => getActionActionsActionIdGet(actionId, signal);

    return { queryKey, queryFn, enabled: !!actionId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionActionsActionIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getActionActionsActionIdGet>>
>;
export type GetActionActionsActionIdGetQueryError = ErrorType<HTTPValidationError>;

export function useGetActionActionsActionIdGet<
    TData = Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getActionActionsActionIdGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getActionActionsActionIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetActionActionsActionIdGet<
    TData = Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getActionActionsActionIdGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getActionActionsActionIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetActionActionsActionIdGet<
    TData = Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getActionActionsActionIdGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Action
 */

export function useGetActionActionsActionIdGet<
    TData = Awaited<ReturnType<typeof getActionActionsActionIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getActionActionsActionIdGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetActionActionsActionIdGetQueryOptions(actionId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Delete an action item. Only Cogniters can delete actions.
 * @summary Delete Action
 */
export const deleteActionActionsActionIdDelete = (actionId: string) => {
    return customInstance<void>({ url: `/actions/${actionId}`, method: "DELETE" });
};

export const getDeleteActionActionsActionIdDeleteMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteActionActionsActionIdDelete>>,
        TError,
        { actionId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteActionActionsActionIdDelete>>,
    TError,
    { actionId: string },
    TContext
> => {
    const mutationKey = ["deleteActionActionsActionIdDelete"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteActionActionsActionIdDelete>>,
        { actionId: string }
    > = (props) => {
        const { actionId } = props ?? {};

        return deleteActionActionsActionIdDelete(actionId);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteActionActionsActionIdDeleteMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteActionActionsActionIdDelete>>
>;

export type DeleteActionActionsActionIdDeleteMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Action
 */
export const useDeleteActionActionsActionIdDelete = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteActionActionsActionIdDelete>>,
            TError,
            { actionId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof deleteActionActionsActionIdDelete>>,
    TError,
    { actionId: string },
    TContext
> => {
    const mutationOptions = getDeleteActionActionsActionIdDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get all comments for an action item.

Both Cogniters and assigned Clients can view comments.
 * @summary Get Action Comments
 */
export const getActionCommentsActionsActionIdCommentsGet = (
    actionId: string,
    signal?: AbortSignal
) => {
    return customInstance<CommentRead[]>({
        url: `/actions/${actionId}/comments`,
        method: "GET",
        signal,
    });
};

export const getGetActionCommentsActionsActionIdCommentsGetQueryKey = (actionId?: string) => {
    return [`/actions/${actionId}/comments`] as const;
};

export const getGetActionCommentsActionsActionIdCommentsGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                TError,
                TData
            >
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetActionCommentsActionsActionIdCommentsGetQueryKey(actionId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>
    > = ({ signal }) => getActionCommentsActionsActionIdCommentsGet(actionId, signal);

    return { queryKey, queryFn, enabled: !!actionId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionCommentsActionsActionIdCommentsGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>
>;
export type GetActionCommentsActionsActionIdCommentsGetQueryError = ErrorType<HTTPValidationError>;

export function useGetActionCommentsActionsActionIdCommentsGet<
    TData = Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                    TError,
                    Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetActionCommentsActionsActionIdCommentsGet<
    TData = Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                    TError,
                    Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetActionCommentsActionsActionIdCommentsGet<
    TData = Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Action Comments
 */

export function useGetActionCommentsActionsActionIdCommentsGet<
    TData = Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    actionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActionCommentsActionsActionIdCommentsGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetActionCommentsActionsActionIdCommentsGetQueryOptions(
        actionId,
        options
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Add a comment to an action item.

Both Cogniters and assigned Clients can comment on actions.
 * @summary Add Action Comment
 */
export const addActionCommentActionsActionIdCommentsPost = (
    actionId: string,
    commentCreate: BodyType<CommentCreate>,
    signal?: AbortSignal
) => {
    return customInstance<CommentRead>({
        url: `/actions/${actionId}/comments`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: commentCreate,
        signal,
    });
};

export const getAddActionCommentActionsActionIdCommentsPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof addActionCommentActionsActionIdCommentsPost>>,
        TError,
        { actionId: string; data: BodyType<CommentCreate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof addActionCommentActionsActionIdCommentsPost>>,
    TError,
    { actionId: string; data: BodyType<CommentCreate> },
    TContext
> => {
    const mutationKey = ["addActionCommentActionsActionIdCommentsPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof addActionCommentActionsActionIdCommentsPost>>,
        { actionId: string; data: BodyType<CommentCreate> }
    > = (props) => {
        const { actionId, data } = props ?? {};

        return addActionCommentActionsActionIdCommentsPost(actionId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type AddActionCommentActionsActionIdCommentsPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof addActionCommentActionsActionIdCommentsPost>>
>;
export type AddActionCommentActionsActionIdCommentsPostMutationBody = BodyType<CommentCreate>;
export type AddActionCommentActionsActionIdCommentsPostMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Add Action Comment
 */
export const useAddActionCommentActionsActionIdCommentsPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof addActionCommentActionsActionIdCommentsPost>>,
            TError,
            { actionId: string; data: BodyType<CommentCreate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof addActionCommentActionsActionIdCommentsPost>>,
    TError,
    { actionId: string; data: BodyType<CommentCreate> },
    TContext
> => {
    const mutationOptions = getAddActionCommentActionsActionIdCommentsPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
