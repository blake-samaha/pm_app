/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * PM App API
 * Automated Project Management Tool API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    HTTPValidationError,
    SyncJobEnqueued,
    SyncJobRead,
    SyncResult,
    SyncStatus,
} from ".././models";

import { customInstance } from "../../orvalMutator";
import type { ErrorType } from "../../orvalMutator";

/**
 * Get the status of a sync job.

Poll this endpoint to check if a sync job has completed.
User must have access to the project the job belongs to.
 * @summary Get Job Status
 */
export const getJobStatusSyncJobsJobIdGet = (jobId: string, signal?: AbortSignal) => {
    return customInstance<SyncJobRead>({ url: `/sync/jobs/${jobId}`, method: "GET", signal });
};

export const getGetJobStatusSyncJobsJobIdGetQueryKey = (jobId?: string) => {
    return [`/sync/jobs/${jobId}`] as const;
};

export const getGetJobStatusSyncJobsJobIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    jobId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>, TError, TData>
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetJobStatusSyncJobsJobIdGetQueryKey(jobId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>> = ({
        signal,
    }) => getJobStatusSyncJobsJobIdGet(jobId, signal);

    return { queryKey, queryFn, enabled: !!jobId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetJobStatusSyncJobsJobIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>
>;
export type GetJobStatusSyncJobsJobIdGetQueryError = ErrorType<HTTPValidationError>;

export function useGetJobStatusSyncJobsJobIdGet<
    TData = Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    jobId: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetJobStatusSyncJobsJobIdGet<
    TData = Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    jobId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetJobStatusSyncJobsJobIdGet<
    TData = Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    jobId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Job Status
 */

export function useGetJobStatusSyncJobsJobIdGet<
    TData = Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    jobId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getJobStatusSyncJobsJobIdGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetJobStatusSyncJobsJobIdGetQueryOptions(jobId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Trigger a full sync for a project (Jira + Precursive).
Only Cogniters can trigger syncs.

This endpoint will:
1. Fetch issues from Jira and create/update ActionItems
2. Fetch project data and financials from Precursive
3. Update the project's last_synced_at timestamp

Returns a SyncResult with details of what was synced.
 * @summary Trigger Sync
 */
export const triggerSyncSyncProjectIdPost = (projectId: string, signal?: AbortSignal) => {
    return customInstance<SyncResult>({ url: `/sync/${projectId}`, method: "POST", signal });
};

export const getTriggerSyncSyncProjectIdPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof triggerSyncSyncProjectIdPost>>,
        TError,
        { projectId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof triggerSyncSyncProjectIdPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationKey = ["triggerSyncSyncProjectIdPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof triggerSyncSyncProjectIdPost>>,
        { projectId: string }
    > = (props) => {
        const { projectId } = props ?? {};

        return triggerSyncSyncProjectIdPost(projectId);
    };

    return { mutationFn, ...mutationOptions };
};

export type TriggerSyncSyncProjectIdPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof triggerSyncSyncProjectIdPost>>
>;

export type TriggerSyncSyncProjectIdPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Trigger Sync
 */
export const useTriggerSyncSyncProjectIdPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof triggerSyncSyncProjectIdPost>>,
            TError,
            { projectId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof triggerSyncSyncProjectIdPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationOptions = getTriggerSyncSyncProjectIdPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Trigger a Jira sync for a project.

Returns 202 Accepted with a job ID. Poll GET /sync/jobs/{job_id} for status.
If a sync is already running for this project, returns the existing job.
 * @summary Sync Jira Only
 */
export const syncJiraOnlySyncProjectIdJiraPost = (projectId: string, signal?: AbortSignal) => {
    return customInstance<SyncJobEnqueued>({
        url: `/sync/${projectId}/jira`,
        method: "POST",
        signal,
    });
};

export const getSyncJiraOnlySyncProjectIdJiraPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof syncJiraOnlySyncProjectIdJiraPost>>,
        TError,
        { projectId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof syncJiraOnlySyncProjectIdJiraPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationKey = ["syncJiraOnlySyncProjectIdJiraPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof syncJiraOnlySyncProjectIdJiraPost>>,
        { projectId: string }
    > = (props) => {
        const { projectId } = props ?? {};

        return syncJiraOnlySyncProjectIdJiraPost(projectId);
    };

    return { mutationFn, ...mutationOptions };
};

export type SyncJiraOnlySyncProjectIdJiraPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof syncJiraOnlySyncProjectIdJiraPost>>
>;

export type SyncJiraOnlySyncProjectIdJiraPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Sync Jira Only
 */
export const useSyncJiraOnlySyncProjectIdJiraPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof syncJiraOnlySyncProjectIdJiraPost>>,
            TError,
            { projectId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof syncJiraOnlySyncProjectIdJiraPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationOptions = getSyncJiraOnlySyncProjectIdJiraPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Trigger a Precursive sync for a project.

Returns 202 Accepted with a job ID. Poll GET /sync/jobs/{job_id} for status.
If a sync is already running for this project, returns the existing job.
 * @summary Sync Precursive Only
 */
export const syncPrecursiveOnlySyncProjectIdPrecursivePost = (
    projectId: string,
    signal?: AbortSignal
) => {
    return customInstance<SyncJobEnqueued>({
        url: `/sync/${projectId}/precursive`,
        method: "POST",
        signal,
    });
};

export const getSyncPrecursiveOnlySyncProjectIdPrecursivePostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof syncPrecursiveOnlySyncProjectIdPrecursivePost>>,
        TError,
        { projectId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof syncPrecursiveOnlySyncProjectIdPrecursivePost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationKey = ["syncPrecursiveOnlySyncProjectIdPrecursivePost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof syncPrecursiveOnlySyncProjectIdPrecursivePost>>,
        { projectId: string }
    > = (props) => {
        const { projectId } = props ?? {};

        return syncPrecursiveOnlySyncProjectIdPrecursivePost(projectId);
    };

    return { mutationFn, ...mutationOptions };
};

export type SyncPrecursiveOnlySyncProjectIdPrecursivePostMutationResult = NonNullable<
    Awaited<ReturnType<typeof syncPrecursiveOnlySyncProjectIdPrecursivePost>>
>;

export type SyncPrecursiveOnlySyncProjectIdPrecursivePostMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Sync Precursive Only
 */
export const useSyncPrecursiveOnlySyncProjectIdPrecursivePost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof syncPrecursiveOnlySyncProjectIdPrecursivePost>>,
            TError,
            { projectId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof syncPrecursiveOnlySyncProjectIdPrecursivePost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationOptions =
        getSyncPrecursiveOnlySyncProjectIdPrecursivePostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get the current sync status for a project.

Returns information about:
- When the project was last synced
- Whether Jira and Precursive integrations are configured
- Active and last completed jobs for each integration
- Summary of last sync results

User must have access to the project (Cogniters: all, Clients: assigned + published).
 * @summary Get Sync Status
 */
export const getSyncStatusSyncProjectIdStatusGet = (projectId: string, signal?: AbortSignal) => {
    return customInstance<SyncStatus>({ url: `/sync/${projectId}/status`, method: "GET", signal });
};

export const getGetSyncStatusSyncProjectIdStatusGetQueryKey = (projectId?: string) => {
    return [`/sync/${projectId}/status`] as const;
};

export const getGetSyncStatusSyncProjectIdStatusGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                TError,
                TData
            >
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetSyncStatusSyncProjectIdStatusGetQueryKey(projectId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>
    > = ({ signal }) => getSyncStatusSyncProjectIdStatusGet(projectId, signal);

    return { queryKey, queryFn, enabled: !!projectId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSyncStatusSyncProjectIdStatusGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>
>;
export type GetSyncStatusSyncProjectIdStatusGetQueryError = ErrorType<HTTPValidationError>;

export function useGetSyncStatusSyncProjectIdStatusGet<
    TData = Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                    TError,
                    Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSyncStatusSyncProjectIdStatusGet<
    TData = Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                    TError,
                    Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSyncStatusSyncProjectIdStatusGet<
    TData = Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Sync Status
 */

export function useGetSyncStatusSyncProjectIdStatusGet<
    TData = Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSyncStatusSyncProjectIdStatusGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetSyncStatusSyncProjectIdStatusGetQueryOptions(projectId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}
