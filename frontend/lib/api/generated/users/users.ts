/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * PM App API
 * Automated Project Management Tool API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    HTTPValidationError,
    ListUsersUsersGetParams,
    UserRead,
    UserRoleUpdate,
} from ".././models";

import { customInstance } from "../../orvalMutator";
import type { ErrorType, BodyType } from "../../orvalMutator";

/**
 * List users with optional filtering.

- **search**: Optional search string for name or email (case-insensitive)
- **role**: Optional filter by role (Cogniter, Client + Financials, or Client)
- **limit**: Maximum number of results to return (default 50, max 200)

Only Cogniters can access this endpoint.
 * @summary List Users
 */
export const listUsersUsersGet = (params?: ListUsersUsersGetParams, signal?: AbortSignal) => {
    return customInstance<UserRead[]>({ url: `/users/`, method: "GET", params, signal });
};

export const getListUsersUsersGetQueryKey = (params?: ListUsersUsersGetParams) => {
    return [`/users/`, ...(params ? [params] : [])] as const;
};

export const getListUsersUsersGetQueryOptions = <
    TData = Awaited<ReturnType<typeof listUsersUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params?: ListUsersUsersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listUsersUsersGet>>, TError, TData>
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListUsersUsersGetQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsersUsersGet>>> = ({ signal }) =>
        listUsersUsersGet(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listUsersUsersGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListUsersUsersGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof listUsersUsersGet>>
>;
export type ListUsersUsersGetQueryError = ErrorType<HTTPValidationError>;

export function useListUsersUsersGet<
    TData = Awaited<ReturnType<typeof listUsersUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: undefined | ListUsersUsersGetParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listUsersUsersGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listUsersUsersGet>>,
                    TError,
                    Awaited<ReturnType<typeof listUsersUsersGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListUsersUsersGet<
    TData = Awaited<ReturnType<typeof listUsersUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params?: ListUsersUsersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listUsersUsersGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listUsersUsersGet>>,
                    TError,
                    Awaited<ReturnType<typeof listUsersUsersGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListUsersUsersGet<
    TData = Awaited<ReturnType<typeof listUsersUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params?: ListUsersUsersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listUsersUsersGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Users
 */

export function useListUsersUsersGet<
    TData = Awaited<ReturnType<typeof listUsersUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params?: ListUsersUsersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listUsersUsersGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getListUsersUsersGetQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Update a user's role.

- Only Cogniters can update user roles
- Cannot promote anyone to Cogniter role (security)
- Can only change between CLIENT and CLIENT_FINANCIALS roles

Use this to upgrade a client to Client + Financials for financial data access.
 * @summary Update User Role
 */
export const updateUserRoleUsersUserIdRolePatch = (
    userId: string,
    userRoleUpdate: BodyType<UserRoleUpdate>
) => {
    return customInstance<UserRead>({
        url: `/users/${userId}/role`,
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        data: userRoleUpdate,
    });
};

export const getUpdateUserRoleUsersUserIdRolePatchMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateUserRoleUsersUserIdRolePatch>>,
        TError,
        { userId: string; data: BodyType<UserRoleUpdate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateUserRoleUsersUserIdRolePatch>>,
    TError,
    { userId: string; data: BodyType<UserRoleUpdate> },
    TContext
> => {
    const mutationKey = ["updateUserRoleUsersUserIdRolePatch"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateUserRoleUsersUserIdRolePatch>>,
        { userId: string; data: BodyType<UserRoleUpdate> }
    > = (props) => {
        const { userId, data } = props ?? {};

        return updateUserRoleUsersUserIdRolePatch(userId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdateUserRoleUsersUserIdRolePatchMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateUserRoleUsersUserIdRolePatch>>
>;
export type UpdateUserRoleUsersUserIdRolePatchMutationBody = BodyType<UserRoleUpdate>;
export type UpdateUserRoleUsersUserIdRolePatchMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update User Role
 */
export const useUpdateUserRoleUsersUserIdRolePatch = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateUserRoleUsersUserIdRolePatch>>,
            TError,
            { userId: string; data: BodyType<UserRoleUpdate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof updateUserRoleUsersUserIdRolePatch>>,
    TError,
    { userId: string; data: BodyType<UserRoleUpdate> },
    TContext
> => {
    const mutationOptions = getUpdateUserRoleUsersUserIdRolePatchMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
