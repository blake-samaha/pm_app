/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * PM App API
 * Automated Project Management Tool API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    HTTPValidationError,
    InviteUserRequest,
    InviteUserResponse,
    ProjectCreate,
    ProjectRead,
    ProjectUpdate,
    UserRead,
} from ".././models";

import { customInstance } from "../../orvalMutator";
import type { ErrorType, BodyType } from "../../orvalMutator";

/**
 * List all projects accessible to the current user.
- Cogniters: see all projects
- Clients: see only assigned projects
 * @summary List Projects
 */
export const listProjectsProjectsGet = (signal?: AbortSignal) => {
    return customInstance<ProjectRead[]>({ url: `/projects/`, method: "GET", signal });
};

export const getListProjectsProjectsGetQueryKey = () => {
    return [`/projects/`] as const;
};

export const getListProjectsProjectsGetQueryOptions = <
    TData = Awaited<ReturnType<typeof listProjectsProjectsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof listProjectsProjectsGet>>, TError, TData>
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListProjectsProjectsGetQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjectsProjectsGet>>> = ({
        signal,
    }) => listProjectsProjectsGet(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listProjectsProjectsGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectsProjectsGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof listProjectsProjectsGet>>
>;
export type ListProjectsProjectsGetQueryError = ErrorType<HTTPValidationError>;

export function useListProjectsProjectsGet<
    TData = Awaited<ReturnType<typeof listProjectsProjectsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listProjectsProjectsGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listProjectsProjectsGet>>,
                    TError,
                    Awaited<ReturnType<typeof listProjectsProjectsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectsProjectsGet<
    TData = Awaited<ReturnType<typeof listProjectsProjectsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listProjectsProjectsGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listProjectsProjectsGet>>,
                    TError,
                    Awaited<ReturnType<typeof listProjectsProjectsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectsProjectsGet<
    TData = Awaited<ReturnType<typeof listProjectsProjectsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listProjectsProjectsGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Projects
 */

export function useListProjectsProjectsGet<
    TData = Awaited<ReturnType<typeof listProjectsProjectsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listProjectsProjectsGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getListProjectsProjectsGetQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Create a new project.
Only Cogniters can create projects.
 * @summary Create Project
 */
export const createProjectProjectsPost = (
    projectCreate: BodyType<ProjectCreate>,
    signal?: AbortSignal
) => {
    return customInstance<ProjectRead>({
        url: `/projects/`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: projectCreate,
        signal,
    });
};

export const getCreateProjectProjectsPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createProjectProjectsPost>>,
        TError,
        { data: BodyType<ProjectCreate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createProjectProjectsPost>>,
    TError,
    { data: BodyType<ProjectCreate> },
    TContext
> => {
    const mutationKey = ["createProjectProjectsPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createProjectProjectsPost>>,
        { data: BodyType<ProjectCreate> }
    > = (props) => {
        const { data } = props ?? {};

        return createProjectProjectsPost(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateProjectProjectsPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof createProjectProjectsPost>>
>;
export type CreateProjectProjectsPostMutationBody = BodyType<ProjectCreate>;
export type CreateProjectProjectsPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Project
 */
export const useCreateProjectProjectsPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createProjectProjectsPost>>,
            TError,
            { data: BodyType<ProjectCreate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof createProjectProjectsPost>>,
    TError,
    { data: BodyType<ProjectCreate> },
    TContext
> => {
    const mutationOptions = getCreateProjectProjectsPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get a specific project by ID.
User must have access to the project.
 * @summary Get Project
 */
export const getProjectProjectsProjectIdGet = (projectId: string, signal?: AbortSignal) => {
    return customInstance<ProjectRead>({ url: `/projects/${projectId}`, method: "GET", signal });
};

export const getGetProjectProjectsProjectIdGetQueryKey = (projectId?: string) => {
    return [`/projects/${projectId}`] as const;
};

export const getGetProjectProjectsProjectIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                TError,
                TData
            >
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetProjectProjectsProjectIdGetQueryKey(projectId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>> = ({
        signal,
    }) => getProjectProjectsProjectIdGet(projectId, signal);

    return { queryKey, queryFn, enabled: !!projectId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectProjectsProjectIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>
>;
export type GetProjectProjectsProjectIdGetQueryError = ErrorType<HTTPValidationError>;

export function useGetProjectProjectsProjectIdGet<
    TData = Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectProjectsProjectIdGet<
    TData = Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectProjectsProjectIdGet<
    TData = Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Project
 */

export function useGetProjectProjectsProjectIdGet<
    TData = Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectProjectsProjectIdGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetProjectProjectsProjectIdGetQueryOptions(projectId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Update a project.
Only Cogniters can update projects.
 * @summary Update Project
 */
export const updateProjectProjectsProjectIdPatch = (
    projectId: string,
    projectUpdate: BodyType<ProjectUpdate>
) => {
    return customInstance<ProjectRead>({
        url: `/projects/${projectId}`,
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        data: projectUpdate,
    });
};

export const getUpdateProjectProjectsProjectIdPatchMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateProjectProjectsProjectIdPatch>>,
        TError,
        { projectId: string; data: BodyType<ProjectUpdate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectProjectsProjectIdPatch>>,
    TError,
    { projectId: string; data: BodyType<ProjectUpdate> },
    TContext
> => {
    const mutationKey = ["updateProjectProjectsProjectIdPatch"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateProjectProjectsProjectIdPatch>>,
        { projectId: string; data: BodyType<ProjectUpdate> }
    > = (props) => {
        const { projectId, data } = props ?? {};

        return updateProjectProjectsProjectIdPatch(projectId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdateProjectProjectsProjectIdPatchMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateProjectProjectsProjectIdPatch>>
>;
export type UpdateProjectProjectsProjectIdPatchMutationBody = BodyType<ProjectUpdate>;
export type UpdateProjectProjectsProjectIdPatchMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update Project
 */
export const useUpdateProjectProjectsProjectIdPatch = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateProjectProjectsProjectIdPatch>>,
            TError,
            { projectId: string; data: BodyType<ProjectUpdate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof updateProjectProjectsProjectIdPatch>>,
    TError,
    { projectId: string; data: BodyType<ProjectUpdate> },
    TContext
> => {
    const mutationOptions = getUpdateProjectProjectsProjectIdPatchMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a project.
Only Cogniters can delete projects.
 * @summary Delete Project
 */
export const deleteProjectProjectsProjectIdDelete = (projectId: string) => {
    return customInstance<void>({ url: `/projects/${projectId}`, method: "DELETE" });
};

export const getDeleteProjectProjectsProjectIdDeleteMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteProjectProjectsProjectIdDelete>>,
        TError,
        { projectId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectProjectsProjectIdDelete>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationKey = ["deleteProjectProjectsProjectIdDelete"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteProjectProjectsProjectIdDelete>>,
        { projectId: string }
    > = (props) => {
        const { projectId } = props ?? {};

        return deleteProjectProjectsProjectIdDelete(projectId);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteProjectProjectsProjectIdDeleteMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteProjectProjectsProjectIdDelete>>
>;

export type DeleteProjectProjectsProjectIdDeleteMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Project
 */
export const useDeleteProjectProjectsProjectIdDelete = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteProjectProjectsProjectIdDelete>>,
            TError,
            { projectId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof deleteProjectProjectsProjectIdDelete>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationOptions = getDeleteProjectProjectsProjectIdDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Publish a project (make it visible to assigned clients).
Only Cogniters can publish projects.
 * @summary Publish Project
 */
export const publishProjectProjectsProjectIdPublishPost = (
    projectId: string,
    signal?: AbortSignal
) => {
    return customInstance<ProjectRead>({
        url: `/projects/${projectId}/publish`,
        method: "POST",
        signal,
    });
};

export const getPublishProjectProjectsProjectIdPublishPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof publishProjectProjectsProjectIdPublishPost>>,
        TError,
        { projectId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof publishProjectProjectsProjectIdPublishPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationKey = ["publishProjectProjectsProjectIdPublishPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof publishProjectProjectsProjectIdPublishPost>>,
        { projectId: string }
    > = (props) => {
        const { projectId } = props ?? {};

        return publishProjectProjectsProjectIdPublishPost(projectId);
    };

    return { mutationFn, ...mutationOptions };
};

export type PublishProjectProjectsProjectIdPublishPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof publishProjectProjectsProjectIdPublishPost>>
>;

export type PublishProjectProjectsProjectIdPublishPostMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Publish Project
 */
export const usePublishProjectProjectsProjectIdPublishPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof publishProjectProjectsProjectIdPublishPost>>,
            TError,
            { projectId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof publishProjectProjectsProjectIdPublishPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationOptions = getPublishProjectProjectsProjectIdPublishPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Unpublish a project (hide from clients).
Only Cogniters can unpublish projects.
 * @summary Unpublish Project
 */
export const unpublishProjectProjectsProjectIdUnpublishPost = (
    projectId: string,
    signal?: AbortSignal
) => {
    return customInstance<ProjectRead>({
        url: `/projects/${projectId}/unpublish`,
        method: "POST",
        signal,
    });
};

export const getUnpublishProjectProjectsProjectIdUnpublishPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof unpublishProjectProjectsProjectIdUnpublishPost>>,
        TError,
        { projectId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof unpublishProjectProjectsProjectIdUnpublishPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationKey = ["unpublishProjectProjectsProjectIdUnpublishPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof unpublishProjectProjectsProjectIdUnpublishPost>>,
        { projectId: string }
    > = (props) => {
        const { projectId } = props ?? {};

        return unpublishProjectProjectsProjectIdUnpublishPost(projectId);
    };

    return { mutationFn, ...mutationOptions };
};

export type UnpublishProjectProjectsProjectIdUnpublishPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof unpublishProjectProjectsProjectIdUnpublishPost>>
>;

export type UnpublishProjectProjectsProjectIdUnpublishPostMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Unpublish Project
 */
export const useUnpublishProjectProjectsProjectIdUnpublishPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof unpublishProjectProjectsProjectIdUnpublishPost>>,
            TError,
            { projectId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof unpublishProjectProjectsProjectIdUnpublishPost>>,
    TError,
    { projectId: string },
    TContext
> => {
    const mutationOptions =
        getUnpublishProjectProjectsProjectIdUnpublishPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get all users assigned to a project.
Only Cogniters can access this endpoint.
 * @summary Get Project Users
 */
export const getProjectUsersProjectsProjectIdUsersGet = (
    projectId: string,
    signal?: AbortSignal
) => {
    return customInstance<UserRead[]>({
        url: `/projects/${projectId}/users`,
        method: "GET",
        signal,
    });
};

export const getGetProjectUsersProjectsProjectIdUsersGetQueryKey = (projectId?: string) => {
    return [`/projects/${projectId}/users`] as const;
};

export const getGetProjectUsersProjectsProjectIdUsersGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                TError,
                TData
            >
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetProjectUsersProjectsProjectIdUsersGetQueryKey(projectId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>
    > = ({ signal }) => getProjectUsersProjectsProjectIdUsersGet(projectId, signal);

    return { queryKey, queryFn, enabled: !!projectId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectUsersProjectsProjectIdUsersGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>
>;
export type GetProjectUsersProjectsProjectIdUsersGetQueryError = ErrorType<HTTPValidationError>;

export function useGetProjectUsersProjectsProjectIdUsersGet<
    TData = Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                    TError,
                    Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectUsersProjectsProjectIdUsersGet<
    TData = Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                    TError,
                    Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectUsersProjectsProjectIdUsersGet<
    TData = Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Project Users
 */

export function useGetProjectUsersProjectsProjectIdUsersGet<
    TData = Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    projectId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getProjectUsersProjectsProjectIdUsersGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetProjectUsersProjectsProjectIdUsersGetQueryOptions(
        projectId,
        options
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Assign a user to a project.
Only Cogniters can assign users.
 * @summary Assign User To Project
 */
export const assignUserToProjectProjectsProjectIdUsersUserIdPost = (
    projectId: string,
    userId: string,
    signal?: AbortSignal
) => {
    return customInstance<void>({
        url: `/projects/${projectId}/users/${userId}`,
        method: "POST",
        signal,
    });
};

export const getAssignUserToProjectProjectsProjectIdUsersUserIdPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof assignUserToProjectProjectsProjectIdUsersUserIdPost>>,
        TError,
        { projectId: string; userId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof assignUserToProjectProjectsProjectIdUsersUserIdPost>>,
    TError,
    { projectId: string; userId: string },
    TContext
> => {
    const mutationKey = ["assignUserToProjectProjectsProjectIdUsersUserIdPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof assignUserToProjectProjectsProjectIdUsersUserIdPost>>,
        { projectId: string; userId: string }
    > = (props) => {
        const { projectId, userId } = props ?? {};

        return assignUserToProjectProjectsProjectIdUsersUserIdPost(projectId, userId);
    };

    return { mutationFn, ...mutationOptions };
};

export type AssignUserToProjectProjectsProjectIdUsersUserIdPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof assignUserToProjectProjectsProjectIdUsersUserIdPost>>
>;

export type AssignUserToProjectProjectsProjectIdUsersUserIdPostMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Assign User To Project
 */
export const useAssignUserToProjectProjectsProjectIdUsersUserIdPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof assignUserToProjectProjectsProjectIdUsersUserIdPost>>,
            TError,
            { projectId: string; userId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof assignUserToProjectProjectsProjectIdUsersUserIdPost>>,
    TError,
    { projectId: string; userId: string },
    TContext
> => {
    const mutationOptions =
        getAssignUserToProjectProjectsProjectIdUsersUserIdPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Remove a user from a project.
Only Cogniters can remove users.
 * @summary Remove User From Project
 */
export const removeUserFromProjectProjectsProjectIdUsersUserIdDelete = (
    projectId: string,
    userId: string
) => {
    return customInstance<void>({
        url: `/projects/${projectId}/users/${userId}`,
        method: "DELETE",
    });
};

export const getRemoveUserFromProjectProjectsProjectIdUsersUserIdDeleteMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof removeUserFromProjectProjectsProjectIdUsersUserIdDelete>>,
        TError,
        { projectId: string; userId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof removeUserFromProjectProjectsProjectIdUsersUserIdDelete>>,
    TError,
    { projectId: string; userId: string },
    TContext
> => {
    const mutationKey = ["removeUserFromProjectProjectsProjectIdUsersUserIdDelete"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof removeUserFromProjectProjectsProjectIdUsersUserIdDelete>>,
        { projectId: string; userId: string }
    > = (props) => {
        const { projectId, userId } = props ?? {};

        return removeUserFromProjectProjectsProjectIdUsersUserIdDelete(projectId, userId);
    };

    return { mutationFn, ...mutationOptions };
};

export type RemoveUserFromProjectProjectsProjectIdUsersUserIdDeleteMutationResult = NonNullable<
    Awaited<ReturnType<typeof removeUserFromProjectProjectsProjectIdUsersUserIdDelete>>
>;

export type RemoveUserFromProjectProjectsProjectIdUsersUserIdDeleteMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Remove User From Project
 */
export const useRemoveUserFromProjectProjectsProjectIdUsersUserIdDelete = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof removeUserFromProjectProjectsProjectIdUsersUserIdDelete>>,
            TError,
            { projectId: string; userId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof removeUserFromProjectProjectsProjectIdUsersUserIdDelete>>,
    TError,
    { projectId: string; userId: string },
    TContext
> => {
    const mutationOptions =
        getRemoveUserFromProjectProjectsProjectIdUsersUserIdDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Invite a user to a project by email.
- If the email exists: assigns the user directly
- If the email doesn't exist: creates a placeholder user and assigns them

Only Cogniters can invite users.
 * @summary Invite User To Project
 */
export const inviteUserToProjectProjectsProjectIdInvitePost = (
    projectId: string,
    inviteUserRequest: BodyType<InviteUserRequest>,
    signal?: AbortSignal
) => {
    return customInstance<InviteUserResponse>({
        url: `/projects/${projectId}/invite`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: inviteUserRequest,
        signal,
    });
};

export const getInviteUserToProjectProjectsProjectIdInvitePostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof inviteUserToProjectProjectsProjectIdInvitePost>>,
        TError,
        { projectId: string; data: BodyType<InviteUserRequest> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof inviteUserToProjectProjectsProjectIdInvitePost>>,
    TError,
    { projectId: string; data: BodyType<InviteUserRequest> },
    TContext
> => {
    const mutationKey = ["inviteUserToProjectProjectsProjectIdInvitePost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof inviteUserToProjectProjectsProjectIdInvitePost>>,
        { projectId: string; data: BodyType<InviteUserRequest> }
    > = (props) => {
        const { projectId, data } = props ?? {};

        return inviteUserToProjectProjectsProjectIdInvitePost(projectId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type InviteUserToProjectProjectsProjectIdInvitePostMutationResult = NonNullable<
    Awaited<ReturnType<typeof inviteUserToProjectProjectsProjectIdInvitePost>>
>;
export type InviteUserToProjectProjectsProjectIdInvitePostMutationBody =
    BodyType<InviteUserRequest>;
export type InviteUserToProjectProjectsProjectIdInvitePostMutationError =
    ErrorType<HTTPValidationError>;

/**
 * @summary Invite User To Project
 */
export const useInviteUserToProjectProjectsProjectIdInvitePost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof inviteUserToProjectProjectsProjectIdInvitePost>>,
            TError,
            { projectId: string; data: BodyType<InviteUserRequest> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof inviteUserToProjectProjectsProjectIdInvitePost>>,
    TError,
    { projectId: string; data: BodyType<InviteUserRequest> },
    TContext
> => {
    const mutationOptions =
        getInviteUserToProjectProjectsProjectIdInvitePostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
