/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * PM App API
 * Automated Project Management Tool API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    CommentCreate,
    CommentRead,
    HTTPValidationError,
    ReadRisksRisksGetParams,
    RiskCreate,
    RiskRead,
    RiskReopen,
    RiskResolve,
} from ".././models";

import { customInstance } from "../../orvalMutator";
import type { ErrorType, BodyType } from "../../orvalMutator";

/**
 * Get all risks for a project.
 * @summary Read Risks
 */
export const readRisksRisksGet = (params: ReadRisksRisksGetParams, signal?: AbortSignal) => {
    return customInstance<RiskRead[]>({ url: `/risks/`, method: "GET", params, signal });
};

export const getReadRisksRisksGetQueryKey = (params?: ReadRisksRisksGetParams) => {
    return [`/risks/`, ...(params ? [params] : [])] as const;
};

export const getReadRisksRisksGetQueryOptions = <
    TData = Awaited<ReturnType<typeof readRisksRisksGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadRisksRisksGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readRisksRisksGet>>, TError, TData>
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getReadRisksRisksGetQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRisksRisksGet>>> = ({ signal }) =>
        readRisksRisksGet(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof readRisksRisksGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadRisksRisksGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof readRisksRisksGet>>
>;
export type ReadRisksRisksGetQueryError = ErrorType<HTTPValidationError>;

export function useReadRisksRisksGet<
    TData = Awaited<ReturnType<typeof readRisksRisksGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadRisksRisksGetParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readRisksRisksGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof readRisksRisksGet>>,
                    TError,
                    Awaited<ReturnType<typeof readRisksRisksGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReadRisksRisksGet<
    TData = Awaited<ReturnType<typeof readRisksRisksGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadRisksRisksGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readRisksRisksGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof readRisksRisksGet>>,
                    TError,
                    Awaited<ReturnType<typeof readRisksRisksGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReadRisksRisksGet<
    TData = Awaited<ReturnType<typeof readRisksRisksGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadRisksRisksGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readRisksRisksGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Read Risks
 */

export function useReadRisksRisksGet<
    TData = Awaited<ReturnType<typeof readRisksRisksGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    params: ReadRisksRisksGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof readRisksRisksGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getReadRisksRisksGetQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Create a new risk.
 * @summary Create Risk
 */
export const createRiskRisksPost = (riskCreate: BodyType<RiskCreate>, signal?: AbortSignal) => {
    return customInstance<RiskRead>({
        url: `/risks/`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: riskCreate,
        signal,
    });
};

export const getCreateRiskRisksPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createRiskRisksPost>>,
        TError,
        { data: BodyType<RiskCreate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createRiskRisksPost>>,
    TError,
    { data: BodyType<RiskCreate> },
    TContext
> => {
    const mutationKey = ["createRiskRisksPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createRiskRisksPost>>,
        { data: BodyType<RiskCreate> }
    > = (props) => {
        const { data } = props ?? {};

        return createRiskRisksPost(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateRiskRisksPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof createRiskRisksPost>>
>;
export type CreateRiskRisksPostMutationBody = BodyType<RiskCreate>;
export type CreateRiskRisksPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Risk
 */
export const useCreateRiskRisksPost = <TError = ErrorType<HTTPValidationError>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createRiskRisksPost>>,
            TError,
            { data: BodyType<RiskCreate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof createRiskRisksPost>>,
    TError,
    { data: BodyType<RiskCreate> },
    TContext
> => {
    const mutationOptions = getCreateRiskRisksPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get a specific risk by ID.
 * @summary Get Risk
 */
export const getRiskRisksRiskIdGet = (riskId: string, signal?: AbortSignal) => {
    return customInstance<RiskRead>({ url: `/risks/${riskId}`, method: "GET", signal });
};

export const getGetRiskRisksRiskIdGetQueryKey = (riskId?: string) => {
    return [`/risks/${riskId}`] as const;
};

export const getGetRiskRisksRiskIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>, TError, TData>
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetRiskRisksRiskIdGetQueryKey(riskId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>> = ({
        signal,
    }) => getRiskRisksRiskIdGet(riskId, signal);

    return { queryKey, queryFn, enabled: !!riskId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRiskRisksRiskIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>
>;
export type GetRiskRisksRiskIdGetQueryError = ErrorType<HTTPValidationError>;

export function useGetRiskRisksRiskIdGet<
    TData = Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRiskRisksRiskIdGet<
    TData = Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRiskRisksRiskIdGet<
    TData = Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Risk
 */

export function useGetRiskRisksRiskIdGet<
    TData = Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getRiskRisksRiskIdGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetRiskRisksRiskIdGetQueryOptions(riskId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Delete a risk. Only Cogniters can delete risks.
 * @summary Delete Risk
 */
export const deleteRiskRisksRiskIdDelete = (riskId: string) => {
    return customInstance<void>({ url: `/risks/${riskId}`, method: "DELETE" });
};

export const getDeleteRiskRisksRiskIdDeleteMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteRiskRisksRiskIdDelete>>,
        TError,
        { riskId: string },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteRiskRisksRiskIdDelete>>,
    TError,
    { riskId: string },
    TContext
> => {
    const mutationKey = ["deleteRiskRisksRiskIdDelete"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteRiskRisksRiskIdDelete>>,
        { riskId: string }
    > = (props) => {
        const { riskId } = props ?? {};

        return deleteRiskRisksRiskIdDelete(riskId);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteRiskRisksRiskIdDeleteMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteRiskRisksRiskIdDelete>>
>;

export type DeleteRiskRisksRiskIdDeleteMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Risk
 */
export const useDeleteRiskRisksRiskIdDelete = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteRiskRisksRiskIdDelete>>,
            TError,
            { riskId: string },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof deleteRiskRisksRiskIdDelete>>,
    TError,
    { riskId: string },
    TContext
> => {
    const mutationOptions = getDeleteRiskRisksRiskIdDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Resolve a risk with a decision record.

- Only Cogniters can resolve risks
- Status must be CLOSED or MITIGATED
- Decision record is required
 * @summary Resolve Risk
 */
export const resolveRiskRisksRiskIdResolvePost = (
    riskId: string,
    riskResolve: BodyType<RiskResolve>,
    signal?: AbortSignal
) => {
    return customInstance<RiskRead>({
        url: `/risks/${riskId}/resolve`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: riskResolve,
        signal,
    });
};

export const getResolveRiskRisksRiskIdResolvePostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof resolveRiskRisksRiskIdResolvePost>>,
        TError,
        { riskId: string; data: BodyType<RiskResolve> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof resolveRiskRisksRiskIdResolvePost>>,
    TError,
    { riskId: string; data: BodyType<RiskResolve> },
    TContext
> => {
    const mutationKey = ["resolveRiskRisksRiskIdResolvePost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof resolveRiskRisksRiskIdResolvePost>>,
        { riskId: string; data: BodyType<RiskResolve> }
    > = (props) => {
        const { riskId, data } = props ?? {};

        return resolveRiskRisksRiskIdResolvePost(riskId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type ResolveRiskRisksRiskIdResolvePostMutationResult = NonNullable<
    Awaited<ReturnType<typeof resolveRiskRisksRiskIdResolvePost>>
>;
export type ResolveRiskRisksRiskIdResolvePostMutationBody = BodyType<RiskResolve>;
export type ResolveRiskRisksRiskIdResolvePostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Resolve Risk
 */
export const useResolveRiskRisksRiskIdResolvePost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof resolveRiskRisksRiskIdResolvePost>>,
            TError,
            { riskId: string; data: BodyType<RiskResolve> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof resolveRiskRisksRiskIdResolvePost>>,
    TError,
    { riskId: string; data: BodyType<RiskResolve> },
    TContext
> => {
    const mutationOptions = getResolveRiskRisksRiskIdResolvePostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Reopen a previously resolved risk.

- Only Cogniters can reopen risks
- Reason is required
 * @summary Reopen Risk
 */
export const reopenRiskRisksRiskIdReopenPost = (
    riskId: string,
    riskReopen: BodyType<RiskReopen>,
    signal?: AbortSignal
) => {
    return customInstance<RiskRead>({
        url: `/risks/${riskId}/reopen`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: riskReopen,
        signal,
    });
};

export const getReopenRiskRisksRiskIdReopenPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof reopenRiskRisksRiskIdReopenPost>>,
        TError,
        { riskId: string; data: BodyType<RiskReopen> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof reopenRiskRisksRiskIdReopenPost>>,
    TError,
    { riskId: string; data: BodyType<RiskReopen> },
    TContext
> => {
    const mutationKey = ["reopenRiskRisksRiskIdReopenPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof reopenRiskRisksRiskIdReopenPost>>,
        { riskId: string; data: BodyType<RiskReopen> }
    > = (props) => {
        const { riskId, data } = props ?? {};

        return reopenRiskRisksRiskIdReopenPost(riskId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type ReopenRiskRisksRiskIdReopenPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof reopenRiskRisksRiskIdReopenPost>>
>;
export type ReopenRiskRisksRiskIdReopenPostMutationBody = BodyType<RiskReopen>;
export type ReopenRiskRisksRiskIdReopenPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Reopen Risk
 */
export const useReopenRiskRisksRiskIdReopenPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof reopenRiskRisksRiskIdReopenPost>>,
            TError,
            { riskId: string; data: BodyType<RiskReopen> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof reopenRiskRisksRiskIdReopenPost>>,
    TError,
    { riskId: string; data: BodyType<RiskReopen> },
    TContext
> => {
    const mutationOptions = getReopenRiskRisksRiskIdReopenPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get all comments for a risk.

Both Cogniters and assigned Clients can view comments.
 * @summary Get Risk Comments
 */
export const getRiskCommentsRisksRiskIdCommentsGet = (riskId: string, signal?: AbortSignal) => {
    return customInstance<CommentRead[]>({
        url: `/risks/${riskId}/comments`,
        method: "GET",
        signal,
    });
};

export const getGetRiskCommentsRisksRiskIdCommentsGetQueryKey = (riskId?: string) => {
    return [`/risks/${riskId}/comments`] as const;
};

export const getGetRiskCommentsRisksRiskIdCommentsGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                TError,
                TData
            >
        >;
    }
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetRiskCommentsRisksRiskIdCommentsGetQueryKey(riskId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>
    > = ({ signal }) => getRiskCommentsRisksRiskIdCommentsGet(riskId, signal);

    return { queryKey, queryFn, enabled: !!riskId, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRiskCommentsRisksRiskIdCommentsGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>
>;
export type GetRiskCommentsRisksRiskIdCommentsGetQueryError = ErrorType<HTTPValidationError>;

export function useGetRiskCommentsRisksRiskIdCommentsGet<
    TData = Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                    TError,
                    Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRiskCommentsRisksRiskIdCommentsGet<
    TData = Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                    TError,
                    Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRiskCommentsRisksRiskIdCommentsGet<
    TData = Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Risk Comments
 */

export function useGetRiskCommentsRisksRiskIdCommentsGet<
    TData = Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    riskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getRiskCommentsRisksRiskIdCommentsGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetRiskCommentsRisksRiskIdCommentsGetQueryOptions(riskId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Add a comment to a risk.

Both Cogniters and assigned Clients can comment on risks.
 * @summary Add Risk Comment
 */
export const addRiskCommentRisksRiskIdCommentsPost = (
    riskId: string,
    commentCreate: BodyType<CommentCreate>,
    signal?: AbortSignal
) => {
    return customInstance<CommentRead>({
        url: `/risks/${riskId}/comments`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: commentCreate,
        signal,
    });
};

export const getAddRiskCommentRisksRiskIdCommentsPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof addRiskCommentRisksRiskIdCommentsPost>>,
        TError,
        { riskId: string; data: BodyType<CommentCreate> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof addRiskCommentRisksRiskIdCommentsPost>>,
    TError,
    { riskId: string; data: BodyType<CommentCreate> },
    TContext
> => {
    const mutationKey = ["addRiskCommentRisksRiskIdCommentsPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof addRiskCommentRisksRiskIdCommentsPost>>,
        { riskId: string; data: BodyType<CommentCreate> }
    > = (props) => {
        const { riskId, data } = props ?? {};

        return addRiskCommentRisksRiskIdCommentsPost(riskId, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type AddRiskCommentRisksRiskIdCommentsPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof addRiskCommentRisksRiskIdCommentsPost>>
>;
export type AddRiskCommentRisksRiskIdCommentsPostMutationBody = BodyType<CommentCreate>;
export type AddRiskCommentRisksRiskIdCommentsPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Add Risk Comment
 */
export const useAddRiskCommentRisksRiskIdCommentsPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof addRiskCommentRisksRiskIdCommentsPost>>,
            TError,
            { riskId: string; data: BodyType<CommentCreate> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof addRiskCommentRisksRiskIdCommentsPost>>,
    TError,
    { riskId: string; data: BodyType<CommentCreate> },
    TContext
> => {
    const mutationOptions = getAddRiskCommentRisksRiskIdCommentsPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
