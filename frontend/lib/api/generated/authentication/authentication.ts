/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * PM App API
 * Automated Project Management Tool API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    GoogleLoginRequest,
    HTTPValidationError,
    SuperuserLoginRequest,
    Token,
    UserRead,
} from ".././models";

import { customInstance } from "../../orvalMutator";
import type { ErrorType, BodyType } from "../../orvalMutator";

/**
 * Login with Firebase ID token.
Supports Google OAuth and Email/Password authentication.
Creates user if doesn't exist.
Returns JWT access token.
 * @summary Login With Firebase
 */
export const loginWithFirebaseAuthLoginPost = (
    googleLoginRequest: BodyType<GoogleLoginRequest>,
    signal?: AbortSignal
) => {
    return customInstance<Token>({
        url: `/auth/login`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: googleLoginRequest,
        signal,
    });
};

export const getLoginWithFirebaseAuthLoginPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof loginWithFirebaseAuthLoginPost>>,
        TError,
        { data: BodyType<GoogleLoginRequest> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof loginWithFirebaseAuthLoginPost>>,
    TError,
    { data: BodyType<GoogleLoginRequest> },
    TContext
> => {
    const mutationKey = ["loginWithFirebaseAuthLoginPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof loginWithFirebaseAuthLoginPost>>,
        { data: BodyType<GoogleLoginRequest> }
    > = (props) => {
        const { data } = props ?? {};

        return loginWithFirebaseAuthLoginPost(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type LoginWithFirebaseAuthLoginPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof loginWithFirebaseAuthLoginPost>>
>;
export type LoginWithFirebaseAuthLoginPostMutationBody = BodyType<GoogleLoginRequest>;
export type LoginWithFirebaseAuthLoginPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Login With Firebase
 */
export const useLoginWithFirebaseAuthLoginPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof loginWithFirebaseAuthLoginPost>>,
            TError,
            { data: BodyType<GoogleLoginRequest> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof loginWithFirebaseAuthLoginPost>>,
    TError,
    { data: BodyType<GoogleLoginRequest> },
    TContext
> => {
    const mutationOptions = getLoginWithFirebaseAuthLoginPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Login as superuser with email/password (bypasses Firebase).
Only works if SUPERUSER_EMAIL and SUPERUSER_PASSWORD are configured.
 * @summary Login Superuser
 */
export const loginSuperuserAuthSuperuserLoginPost = (
    superuserLoginRequest: BodyType<SuperuserLoginRequest>,
    signal?: AbortSignal
) => {
    return customInstance<Token>({
        url: `/auth/superuser-login`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: superuserLoginRequest,
        signal,
    });
};

export const getLoginSuperuserAuthSuperuserLoginPostMutationOptions = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof loginSuperuserAuthSuperuserLoginPost>>,
        TError,
        { data: BodyType<SuperuserLoginRequest> },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof loginSuperuserAuthSuperuserLoginPost>>,
    TError,
    { data: BodyType<SuperuserLoginRequest> },
    TContext
> => {
    const mutationKey = ["loginSuperuserAuthSuperuserLoginPost"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof loginSuperuserAuthSuperuserLoginPost>>,
        { data: BodyType<SuperuserLoginRequest> }
    > = (props) => {
        const { data } = props ?? {};

        return loginSuperuserAuthSuperuserLoginPost(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type LoginSuperuserAuthSuperuserLoginPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof loginSuperuserAuthSuperuserLoginPost>>
>;
export type LoginSuperuserAuthSuperuserLoginPostMutationBody = BodyType<SuperuserLoginRequest>;
export type LoginSuperuserAuthSuperuserLoginPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Login Superuser
 */
export const useLoginSuperuserAuthSuperuserLoginPost = <
    TError = ErrorType<HTTPValidationError>,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof loginSuperuserAuthSuperuserLoginPost>>,
            TError,
            { data: BodyType<SuperuserLoginRequest> },
            TContext
        >;
    },
    queryClient?: QueryClient
): UseMutationResult<
    Awaited<ReturnType<typeof loginSuperuserAuthSuperuserLoginPost>>,
    TError,
    { data: BodyType<SuperuserLoginRequest> },
    TContext
> => {
    const mutationOptions = getLoginSuperuserAuthSuperuserLoginPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
/**
 * Get current authenticated user information.
 * @summary Get Current User Info
 */
export const getCurrentUserInfoAuthMeGet = (signal?: AbortSignal) => {
    return customInstance<UserRead>({ url: `/auth/me`, method: "GET", signal });
};

export const getGetCurrentUserInfoAuthMeGetQueryKey = () => {
    return [`/auth/me`] as const;
};

export const getGetCurrentUserInfoAuthMeGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
    TError = ErrorType<HTTPValidationError>,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError, TData>
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetCurrentUserInfoAuthMeGetQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>> = ({
        signal,
    }) => getCurrentUserInfoAuthMeGet(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCurrentUserInfoAuthMeGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>
>;
export type GetCurrentUserInfoAuthMeGetQueryError = ErrorType<HTTPValidationError>;

export function useGetCurrentUserInfoAuthMeGet<
    TData = Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
                    TError,
                    Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCurrentUserInfoAuthMeGet<
    TData = Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
                    TError,
                    Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCurrentUserInfoAuthMeGet<
    TData = Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Current User Info
 */

export function useGetCurrentUserInfoAuthMeGet<
    TData = Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>,
    TError = ErrorType<HTTPValidationError>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetCurrentUserInfoAuthMeGetQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Return stable QA personas for superuser impersonation.

This endpoint is superuser-only (checked via JWT claim), and is safe to call even
while the superuser is impersonating another user.
 * @summary Get Impersonation Presets
 */
export const getImpersonationPresetsAuthImpersonationPresetsGet = (signal?: AbortSignal) => {
    return customInstance<UserRead[]>({
        url: `/auth/impersonation-presets`,
        method: "GET",
        signal,
    });
};

export const getGetImpersonationPresetsAuthImpersonationPresetsGetQueryKey = () => {
    return [`/auth/impersonation-presets`] as const;
};

export const getGetImpersonationPresetsAuthImpersonationPresetsGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
            TError,
            TData
        >
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetImpersonationPresetsAuthImpersonationPresetsGetQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>
    > = ({ signal }) => getImpersonationPresetsAuthImpersonationPresetsGet(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetImpersonationPresetsAuthImpersonationPresetsGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>
>;
export type GetImpersonationPresetsAuthImpersonationPresetsGetQueryError = ErrorType<unknown>;

export function useGetImpersonationPresetsAuthImpersonationPresetsGet<
    TData = Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
    TError = ErrorType<unknown>,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
                    TError,
                    Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetImpersonationPresetsAuthImpersonationPresetsGet<
    TData = Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
                    TError,
                    Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetImpersonationPresetsAuthImpersonationPresetsGet<
    TData = Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Impersonation Presets
 */

export function useGetImpersonationPresetsAuthImpersonationPresetsGet<
    TData = Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getImpersonationPresetsAuthImpersonationPresetsGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetImpersonationPresetsAuthImpersonationPresetsGetQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}
